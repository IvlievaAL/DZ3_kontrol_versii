# GIT список команд
![Здесь находится мем1](image1.jpg)

Проверить, **установлен ли гит** на этом компе и какая его версия: *git version*. Если есть на этот счет сомнения, или сомнения насчет правильности установки гита, то это сюда.

Как **вызвать справку** от гита о нем самом: *git help -a* (вылезет полная справка по всему вообще) или *git help конкретнаякомандаилифлаг* (по ней и вылезет). Чтобы выйти из этой простыни, нажми ***q***
* **сделать** текущую **папку репозиторием**: *git init*
* далее **надо представиться гиту** (вроде как один раз): *git config --global user.name* "Имя пользователя" и  *git config --global user.email* почта
* **начать отслеживать** конкретный файл: *git add имяфайла.расширение*. **Файлы называть без пробелов!** Также можно гаком начать отслеживать все файлы, на данный момент находящиеся в конкретной папке (только не ВНЕ репозитория!): *git add имяпапки*

потом можно печатать что нужно в файле

***Как сохранить версию файла:***
* **первым делом сохранить его**, обычным сохранением, через меню программы или Ctrl+S
* команда *git add имяфайла.расширение* снова

можно для собственного спокойствия вызвать *git status* и убедиться, что он пишет о наличии неоткоммиченных изменений в файле (**внимание, если какой-то из предыдущих шагов забыт**, статус выдаст, что никаких изменений в файле не было, даже когда они, очевидно, были - это сигнал проверить, что пропущено) 
* и сделать коммит с комментарием о внесенных изменениях: *git commit -m"комментарий"* или, вариант с флагом, *git commit -a -m"комментарий"*. ВНИМАНИЕ: флаг *-a* приведет **к созданию коммита во всех** отслеживаемых в данном репозитории файлах. Если этого не нужно, то флаг не ставить.

**Если набрать** просто *git commit* **без ничего**, то выкинет в редактор Vim или создаст аналогичную тому вкладку рядом со вкладкой файла. Редактор позволяет вручную набрать то, что хочешь от своего коммита. Если этого не нужно, то если вкладка, то закрыть ее, а если редактор, то набрать команду на выход из него без сохранения ***:q!***

**Эти шаги повторяются в этом порядке всякий раз при сохранении изменений.**

Посмотреть, какие коммиты и сколько их было сделано, можно ваызовом журнала изменений *git log*. **Внимание, чтобы выйти из режима журнала в обычный режим, надо нажать на клавишу q** (обнаружено, что ею же выходить надо из спецрежимов команд *git diff*, *git help*, *git reflog*). При наличии нескольких веток (см.ниже) полезно набрать *git log --graph*: журнал высветится с вертикальной схемой ветвления.

Если собъешся вообще, что и в какой последовательности творишь с файлом, есть крутая (и опасная возможной потерй коммитов) фича *git reflog*: это журнал действий в гите, совершенных с файлом - гит их все помнит! Каждому действию в нем присвоен номер, он желтым слева высвечен: с его помощью можно откатить время назад до определенного действия - но это откатит все совершенные позже действия, включая коммиты!

Как велеть гиту **прекратить отслеживать** файл:

* Прекратить отслеживание **одного из** поднадзорных файлов: *git rm --cached имяфайла.расширение* Опционально потом добавить этот файл в гитигнор (см.ниже), чтобы гит не напоминал о нем.
* Прекратить отслеживание **всех** поднадзорных файлов в конкретной папке: *git rm --cached имяпапки*
* **Если весь репозиторий** перестал быть нужным, то просто удалить скрытую папку ***.git*** через проводник (ВНИМАНИЕ! **Перед удалением** этого файла **закрыть VS Code!**)

![Здесь находится мем2](image2.jpg)
## Коммиты и ветки, или как переключаться между версиями файла.
**Коммиты** = собственно версии файла, а точнее, наборы различий между двумя соседними по времени сохранения версиями файла. Они по порядку их создания группируются гитом в **ветви** - последовательности коммитов. Переключаться можно как между отдельными коммитами, так и между ветвями. Команда на переключение: *git checkout номеркоммита* (длинная последовательность символов в абзаце желаемого коммита в журнале изменений) или *git checkout имя_желаемой_ветви*.

Внимание! Если переключиться **между отдельными коммитами**, возникнет состояние ***DETACHED HEAD***, о котором гит вдобавок выдаст оповещение в терминале. Что это такое: гит теперь не понимает, а где же, из всех сделанных коммитов, находится последнее, самое текущее, состояние файла, где крайний на данный момент коммит, где свободный конец ветки. Отныне все текущие изменения файла с точки зрения гита "подвешены в пустоте" - они не входят ни в тот коммит, на который мы переключились, ни в одну из имеющихся ветвей. В этом состоянии **файл можно менять, но вот сделать новый коммит гит не может** - и статус будет выдавать все время, что никаких изменений для сохранения не имеется.

**Исправляется** это: 
* Если **изменений** в файл **не внесено** и перескок был между коммитами **одной** ветки, надо просто **показать** гиту, **где** тот свободный **конец ветки**: *git checkout HEAD@{1}*
* Если **изменений** в файл **не внесено**, то можно **переключиться на последний коммит той ветки**, где мы были до перескока: *git checkout имяжелаемойветки*. Если забыли, на какой ветке до того находились, можно спросить об этом гит: *git reflog*
* А вот **если файл** в этом состоянии был **изменен**, то спасать изменения надо через **создание дополнительной** ветки. 

**4 команды надо вбить** для этого: 
1. создаем временную ветку с именем temp, причем в новой ветке будет правильно установлено положение HEAD: git branch temp
2. переключаемся на временную ветку temp: git checkout temp
3. в ветке master устанавливается та же позиция HEAD, что и в ветке temp: git branch -f master temp
4. переключиться на ветку master: git checkout master
5. И **закоммитить** сделанное!
6. Опционально, можно потом удалить временную ветку (см.ниже, как)

**Ветки** - параллельные друг другу последовательности коммитов, обозначаются именами, заданными пользователем при их создании. Ветвление можно сделать в любой момент от любой ветки; при начале отслеживания файла гит создает единственную, по умолчанию, ветку master (название по умолчанию можно поменять в настройках - например, на гитхабе (см.ниже) главную ветку называют main): от нее и начинается ветвление. 

При совместной работе над проектом вежливо делать дочерние ветки только от master (или main, или как еще называется основная ветка проекта), а не дочерние от дочерних.

Статус укажет, в какой ветке мы сейчас находимся.

**Создание ветки** от той, на которой ты сейчас находишься: *git branch имя_новой_ветки_желательно_отражающее_смысл_ее_содержимого* или сразу *git checkout -b имя_новой_ветки_желательно_отражающее_смысл_ее_содержимого* (тогда сразу переключишься на свежесозданную ветку). 

Внимание! Теперь:
* Созданный коммит будет **записан только и именно в ту ветку, в который ты сейчас находишься**. При переключении на ветку будет видна версия файла, соответствующая последнему созданному в данной конкретной ветке коммиту. 
* Журнал изменений покажет в обратном порядке **коммиты текущей ветки и коммиты той ветки, от которой текущая ветка отходит**: и так далее, по дереву ветвей, к его началу, то есть вплоть до самого первого коммита.

Когда в данную ветку закончили вносить изменения, и все в ней ОК, ее можно **слить с другой веткой**: по логике вещей, чаще сливают ее с ее же материнской, хотя можно и с любой другой, если необходимо. 

Для слияния надо: 
1. **Переключиться на ту ветку, в которую мы хотим внести** коммиты из нашей законченной ветки;
2. *git merge имя_законченной_ветки*

Гит автоматически добавит коммиты ***из названной в команде ветки в ту ветку, на которой мы находились*** на момент подачи команды на слияние.

При слиянии может возникнуть ***конфликт***: если **в обеих сливаемых ветвях после последнего общего для них коммита были сделаны коммиты**, то у гита при слиянии в наличии **обнаруживаются две версии** последовательностей коммитов, которые нужно упихать теперь в одну. Самостоятельно гит этого не сделает, и спросит пользователя, какую из версий оставить, или же оставить их обе. **Выбрать**, что хочешь: это гит и сохранит в той ветке, где мы находимся. **После разрешения** конфликта обязательно сделать **коммит**!

**Когда** над файлом **трудятся несколько** человек, **назначается один ответственный за слияние** ветвей: и только он слияние и делает, когда убедится в полной готовности ветвей.

![Здесь находится мем3](image3.png)

Еще команды, относящиеся к ветвям:
* **Вывести список всех** имеющихся ветвей: *git branch* Та ветка, на которой мы сейчас находимся, будет выделена зеленым цветом.
* **Удалить** ненужную ветку: *git branch -d имя_удаляемой_ветки* Гит может отказаться сразу удалить: напишет, что error: branch not fully merged. Это не ошибка, а предупреждение с целью не потерять коммиты удаляемой ветки: это значит, что в удаляемой ветке есть коммиты, котрых нет ни в одной из других ветвей. Если ты в курсе и все равно хочешь ветку удалить, гит сам предложит ввести усиленную команду *git branch -D имя_удаляемой_ветки* - и тогда удалит ее.
* **Сравнить** два последних коммита: *git diff* (покажет разницу между коммитами текущей ветки) или *git diff ветка1 ветка2* (покажет разницу между последними коммитами двух указанных веток)
* **Переименовать текущую** ветку: *git branch -m новоеимяветки*

## Когда в репозитории лежит не один файл
В папке, ставшей по воле владельца гита репозиторием, может лежать несколько файлов. Каких - зависит от конкретного случая: несколько текстов, картинки для вставки в текст, etc. Гит видит все эти файлы: и если они в гит не добавлены (*git add имяфайла.расширение*), т.е. он их не отслеживает, всякий раз статус будет напоминать, что они есть и не отслеживаются (и буковку U рисовать напротив них в списке файлов).

Чтобы **избавиться от** настойчивых **напоминалок** гита **про неотслеживаемые файлы**, можно сделать специальное действие: создать в этой папке - через список файлов в левой менюшке - файл со специальным названием ***.gitignore***. В нем в строки, по одной на имя, написать имя одного из файлов, которые гиту надо игнорировать. После составления этого списка добавить этот файл в гит как отслеживаемый, и сделать коммит. И больше статус напоминать о перечисленных файлах не будет: гит перестанет обращать на них внимание (хотя будет видеть и отображать их присутствие в репозитории).

**Как добавить картинки** в создаваемый в Visual Studio Code файл:

1. Лучше создать для картинок отдельную ветку (и переключиться на нее не забыть)
2. На языке разметки Markdown (что использован в этом файле) команда на вставку картинки будет ***![Текст, который будет отображаться вместо картинки, если ее не удастся отобразить](адрес картинки или, если картинка лежит в том же репозитории, что и тот файл, в который мы ее вносим, просто имякартинки.расширение)***
3. Закоммитить изменения!

Картинки и пр. добавляемые файлы, особенно если они большие, добавлять в гит не принято, и они лежат в репозитории как неотслеживаемые. Можно их добавить в гитигнор.

## Работа с удаленным репозиторием GitHub
**Удаленные репозитории** - основное средство для работы над файлом нескольких человек. **На сайте GitHub** выкладывается в создаваемый на сайте репозиторий **начальная/текущая, она же общая для всех версия файла**. Гитхаб **присвоит этому репозиторию ссылку**, которую можно и нужно скопировать, рассылать кому хочешь и т.д. По этой ссылке репозиторий может скачать любой человек, даже не имеющий акаунта в данном сервисе удаленных репозиториев. 

Каждый член команды проекта: 
* **копирует общую версию себе** на комп: *git clone ссылканарепозиторийсгнерированнаягитхабом*
* **вносит** на своем компе в нее **изменения и коммитит их**
* **подгружает себе** коммиты с удаленного репозитория - как залитые туда другими членами команды, так и сделанные тобою же непосредственно на гитхабе: *git pull  ссылканарепозиторийсгнерированнаягитхабом*
* **подгружает сделанные им коммиты** (т.е. свою версию файла) (*git push ссылканарепозиторийсгнерированнаягитхабом*) в ту самую общую для всех версию файла в удаленном репозитории. Можно подгрузить конкретную ветку: *git push ссылканарепозиторийсгнерированнаягитхабом имя_конкретной_ветки*

ВНИМАНИЕ! 

*git clone* **набирается** в терминале **после открытия** в Visual Studio Code **той папки, в которую** планируешь **положить** скачиваемый проект. Гит **создаст папку** с нужным файлом **внутри этой папки**: надо будет перейти на ту папку и открыть в ней терминал.

*git pull* автоматически **подразумевает** *merge* между локальной и подгружаемой с гитхаба версиями файла: т.е. **когда/если возникнут конфликты** при слиянии, с ними надо будет разобраться (см.выше, как это делать)

Для *git push* **необходимо быть авторизованной на внешнем**, то есть удаленном, т.е. гитхабовском в данном случае, **репозитории**. Надо "подружить" свой гит с аккаунтом на гитхабе: и гит подскажет, как это сделать, если набрать *git push*, а связки еще не было, и гитхаб предложит скопировать с него набор команд на выбор, смотря что хочешь сделать.
Также эта команда **не позволит выполнить** подгрузку, **если в удаленном репозитории были изменения, конфликтующие** с теми, которые мы пытаемся туда подгрузить: делается это для того, чтобы не потерять журнал изменений удаленного репозитория. В таком случае сначала надо подгрузить эти изменения себе на комп, лучше отдельной веткой, слить их со своей версией и тогда уже подгрузить ее на удаленный репозиторий. Есть способ пересилить этот запрет: *git push ссылканарепозиторийсгнерированнаягитхабом --force* - но лучше так не делать! Возненавидят.

Хорошим тоном считается **создать** в репозитории с проектом **файл-описание**: он называется стандартно ***README.md***. ЕГо можно создать как вручную у себя, так и при создании удаленного репозитория - гитхаб предложит сразу его создать. Туда пишем, что это за проект вообще и пр.сведения о нем. Добавить его в гит и закоммитить внесенную туда инфу не забывать!

Еще такая ситуация возникает, когда много человек хотят внести изменения в проект: прямо вот всем 100500 желающим позволить вносить свои правки в проект нельзя, гиблое дело, но кто-то из них дело может предлагать. **Опция предложения изменений** для проекта ***pull request***:

1. На гитхабе **создать** в своем профиле **собственное ответвление** интересующего нас **проекта**. Для этого заходим **на страницу репозитория того самого проекта**, и справа вверху будет **кнопка** ***fork***.
2. **Подгрузить к себе** на комп (*git clone ссылканарепозиторийсгнерированнаягитхабом*) **СВОЮ копию** того репозитория
3. **В локальной версии** сделать **свою ветку и туда** вносить и коммитить свои изменения
4. **README.md создать** (если его еще не было) **или заполнить** инфой о том, что предлагаешь изменить в проекте, обязательно!
5. **Подгрузить** свою версию **в свою копию удаленного** репозитория того проекта (*git push ссылканарепозиторийсгнерированнаягитхабом*)
6. **На гитхабе** на странице удаленного репозитория **появится кнопка** ***Compare and pull request***. Она открывает окошко, где гит сам сравнит две версии проекта, покажет, можно их слить или какие-то проблемы могут возникнуть при слиянии, и предложит накидать послание владельцу исходной версии. Далее уже хозяин исходника будет запрос смотреть и решать, вливать ли это к себе.