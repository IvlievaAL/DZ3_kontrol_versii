# GIT список команд
![Здесь находится мем1](image1.jpg)

* сделать текущую папку репозиторием: *git init*
* далее **надо представиться гиту** (вроде как один раз): *git config --global user.name* "Имя пользователя" и  *git config --global user.email* почта
* начать отслеживать конкретный файл: *git add имяфайла.расширение*. **Файлы называть без пробелов!**

потом можно печатать что нужно в файле

***Как сохранить версию файла:***
* **первым делом сохранить его**, обычным сохранением, через меню программы или Ctrl+S
* команда *git add имяфайла.расширение* снова

можно для собственного спокойствия вызвать *git status* и убедиться, что он пишет о наличии неоткоммиченных изменений в файле (**внимание, если какой-то из предыдущих шагов забыт**, статус выдаст, что никаких изменений в файле не было, даже когда они, очевидно, были - это сигнал проверить, что пропущено) 
* и сделать коммит с комментарием о внесенных изменениях: *git commit -a -m* "комментарий"

**Эти шаги повторяются в этом порядке всякий раз при сохранении изменений.**

Посмотреть, какие коммиты и сколько их было сделано, можно ваызовом журнала изменений *git log*. **Внимание, чтобы выйти из режима журнала в обычный режим, надо нажать на клавишу q** (обнаружено, что ею же выходить надо из спецрежима команды *git diff*)

![Здесь находится мем2](image2.jpg)
## Коммиты и ветки, или как переключаться между версиями файла.
**Коммиты** = собственно версии файла, а точнее, наборы различий между двумя соседними по времени сохранения версиями файла. Они по порядку их создания группируются гитом в **ветви** - последовательности коммитов. Переключаться можно как между отдельными коммитами, так и между ветвями. Команда на переключение: *git checkout номеркоммита* (длинная последовательность символов в абзаце желаемого коммита в журнале изменений) или *git checkout имя_желаемой_ветви*.

Внимание! Если переключиться **между отдельными коммитами**, возникнет состояние ***DETACHED HEAD***, о котором гит вдобавок выдаст оповещение в терминале. Что это такое: отныне все текущие изменения файла с точки зрения гита "подвешены в пустоте" - они не входят ни в тот коммит, на который мы переключились, ни в одну из имеющихся ветвей. В этом состоянии **файл можно менять, но вот сделать новый коммит гит не может** - и статус будет выдавать все время, что никаких изменений для сохранения не имеется. Исправляется это через создание дополнительной ветки для этих изменений. *с подробностями разберусь и добавлю позже, если возникнет такая необходимость - после неуютного самостоятельного знакомства с этой особенностью во время повторения за Ильнаром на лекции 1 вызывать ее намеренно не хочу*

**Ветки** - параллельные друг другу последовательности коммитов, обозначаются именами, заданными пользователем при их создании. Ветвление можно сделать в любой момент от любой ветки; при начале отслеживания файла гит создает единственную, по умолчанию, ветку master, от нее и начинается ветвление. 

**Создание ветки**: *git branch имя_новой_ветки_желательно_отражающее_смысл_ее_содержимого*. Статус укажет, в какой ветке мы сейчас находимся.


Внимание! Теперь:
* Созданный коммит будет **записан только и именно в ту ветку, в который ты сейчас находишься**. При переключении на ветку будет видна версия файла, соответствующая последнему созданному в данной конкретной ветке коммиту. 
* Журнал изменений покажет в обратном порядке **коммиты текущей ветки и коммиты той ветки, от которой текущая ветка отходит**: и так далее, по дереву ветвей, к его началу, то есть вплоть до самого первого коммита.

Когда в данную ветку закончили вносить изменения, и все в ней ОК, ее можно **слить с другой веткой**: по логике вещей, чаще сливают ее с ее же материнской, хотя можно и с любой другой, если необходимо. 

Для слияния надо: 
1. **Переключиться на ту ветку, в которую мы хотим внести** коммиты из нашей законченной ветки;
2. *git merge имя_законченной_ветки*

Гит автоматически добавит коммиты ***из названной в команде ветки в ту ветку, на которой мы находились*** на момент подачи команды на слияние.

При слиянии может возникнуть ***конфликт***: если **в обеих сливаемых ветвях после последнего общего для них коммита были сделаны коммиты**, то у гита при слиянии в наличии **обнаруживаются две версии** последовательностей коммитов, которые нужно упихать теперь в одну. Самостоятельно гит этого не сделает, и спросит пользователя, какую из версий оставить, или же оставить их обе. **Выбрать**, что хочешь: это гит и сохранит в той ветке, где мы находимся.

![Здесь находится мем3](image3.png)

Еще команды, относящиеся к ветвям:
* **Удалить** ненужную ветку: *git branch -d имя_удаляемой_ветки*
* **Сравнить** две ветки (точнее, их последние коммиты): вроде можно при помощи *git diff*, но у меня не вышло :(
## Работа с удаленным репозиторием GitHub
**Удаленные репозитории** - основное средство для работы над файлом нескольких человек. **На сайте GitHub** выкладывается в создаваемый на сайте репозиторий **начальная/текущая, она же общая для всех версия файла**. Гитхаб **присвоит этому репозиторию ссылку**, которую нужно скопировать. Каждый член команды: 
* **копирует общую версию себе** на комп: *git clone ссылканарепозиторийсгнерированнаягитхабом* 
* **вносит** на своем компе в нее **изменения и коммитит их**
* **подгружает себе** коммиты, сделанные другими членами команды: *git pull  ссылканарепозиторийсгнерированнаягитхабом*
* **подгружает сделанные им коммиты** (т.е. свою версию файла) (*git push ссылканарепозиторийсгнерированнаягитхабом*) в ту самую общую для всех версию файла в удаленном репозитории

ВНИМАНИЕ! 

*git pull* автоматически **подразумевает** *merge* между локальной и подгружаемой с гитхаба версиями файла: т.е. **когда/если возникнут конфликты** при слиянии, с ними надо будет разобраться (см.выше, как это делать)

Для *git push* **необходимо быть авторизованной на внешнем**, то есть гитхабовском в данном случае, **репозитории**. Надо "подружить" свой гит с аккаунтом на гитхабе.